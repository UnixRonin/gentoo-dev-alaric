--- pidgin-2.10.9/pidgin/gtkconv.c	2014-02-02 16:29:20.000000000 -0500
+++ pidgin-2.10.9/pidgin/gtkconv.c	2014-06-10 13:23:36.168094006 -0400
@@ -68,10 +68,16 @@
 #include "pidginstock.h"
 #include "pidgintooltip.h"
 
 #include "gtknickcolors.h"
 
+/*
+ *  set this to 1 to restore default behavior of Up/Down keys:  Ctrl+Up/Ctrl+Dn for history
+ *  set to 0 for shell-like/IRC-like behavior:  Up/Dn for history
+ */
+#define HISTORY_USES_CTRL 0
+
 #define CLOSE_CONV_TIMEOUT_SECS  (10 * 60)
 
 #define AUTO_RESPONSE "&lt;AUTO-REPLY&gt; : "
 
 typedef enum
@@ -2015,11 +2021,11 @@
 
 	if (conv_keypress_common(gtkconv, event))
 		return TRUE;
 
 	/* If CTRL was held down... */
-	if (event->state & GDK_CONTROL_MASK) {
+	if ((event->state & GDK_CONTROL_MASK) && HISTORY_USES_CTRL) {
 		switch (event->keyval) {
 			case GDK_Up:
 				if (!gtkconv->send_history)
 					break;
 
@@ -2114,15 +2120,124 @@
 				break;
 		} /* End of switch */
 	}
 
 	/* If ALT (or whatever) was held down... */
-	else if (event->state & GDK_MOD1_MASK) 	{
-
+	else if (event->state & GDK_MOD1_MASK) {
 	}
 
 	/* If neither CTRL nor ALT were held down... */
+	else if (!HISTORY_USES_CTRL)
+	{
+	    switch (event->keyval) 
+	    {
+	  	case GDK_Up:
+			if (!gtkconv->send_history)
+			{
+				break;
+			}
+
+			if (gtkconv->entry != entry)
+			{
+				break;
+			}
+
+			if (!gtkconv->send_history->prev)
+			{
+				GtkTextIter start, end;
+
+				g_free(gtkconv->send_history->data);
+
+				gtk_text_buffer_get_start_iter(gtkconv->entry_buffer,
+												   &start);
+				gtk_text_buffer_get_end_iter(gtkconv->entry_buffer, &end);
+
+				gtkconv->send_history->data =
+					gtk_imhtml_get_markup(GTK_IMHTML(gtkconv->entry));
+			}
+
+			if (gtkconv->send_history->next && gtkconv->send_history->next->data)
+			{
+				GObject *object;
+				GtkTextIter iter;
+				GtkTextBuffer *buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(gtkconv->entry));
+
+				gtkconv->send_history = gtkconv->send_history->next;
+
+				/* Block the signal to prevent application of default formatting. */
+				object = g_object_ref(G_OBJECT(gtkconv->entry));
+				g_signal_handlers_block_matched(object, G_SIGNAL_MATCH_DATA, 0, 0, NULL,
+													NULL, gtkconv);
+				/* Clear the formatting. */
+				gtk_imhtml_clear_formatting(GTK_IMHTML(gtkconv->entry));
+				/* Unblock the signal. */
+				g_signal_handlers_unblock_matched(object, G_SIGNAL_MATCH_DATA, 0, 0, NULL,
+													  NULL, gtkconv);
+				g_object_unref(object);
+
+				gtk_imhtml_clear(GTK_IMHTML(gtkconv->entry));
+				gtk_imhtml_append_text_with_images(
+					GTK_IMHTML(gtkconv->entry), gtkconv->send_history->data,
+					0, NULL);
+				/* this is mainly just a hack so the formatting at the
+				 * cursor gets picked up. */
+				gtk_text_buffer_get_end_iter(buffer, &iter);
+				gtk_text_buffer_move_mark_by_name(buffer, "insert", &iter);
+			}
+
+			return TRUE;
+			break;
+
+		case GDK_Down:
+			if (!gtkconv->send_history)
+			{
+				break;
+			}
+
+			if (gtkconv->entry != entry)
+			{
+				break;
+			}
+
+			if (gtkconv->send_history->prev && gtkconv->send_history->prev->data)
+			{
+				GObject *object;
+				GtkTextIter iter;
+				GtkTextBuffer *buffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(gtkconv->entry));
+
+				gtkconv->send_history = gtkconv->send_history->prev;
+
+				/* Block the signal to prevent application of default formatting. */
+				object = g_object_ref(G_OBJECT(gtkconv->entry));
+				g_signal_handlers_block_matched(object, G_SIGNAL_MATCH_DATA, 0, 0, NULL,
+													NULL, gtkconv);
+				/* Clear the formatting. */
+				gtk_imhtml_clear_formatting(GTK_IMHTML(gtkconv->entry));
+				/* Unblock the signal. */
+				g_signal_handlers_unblock_matched(object, G_SIGNAL_MATCH_DATA, 0, 0, NULL,
+													  NULL, gtkconv);
+				g_object_unref(object);
+
+				gtk_imhtml_clear(GTK_IMHTML(gtkconv->entry));
+				gtk_imhtml_append_text_with_images(
+				GTK_IMHTML(gtkconv->entry), gtkconv->send_history->data,
+					0, NULL);
+				/* this is mainly just a hack so the formatting at the
+				 * cursor gets picked up. */
+				if (*(char *)gtkconv->send_history->data) {
+					gtk_text_buffer_get_end_iter(buffer, &iter);
+					gtk_text_buffer_move_mark_by_name(buffer, "insert", &iter);
+				} else {
+					/* Restore the default formatting */
+					default_formatize(gtkconv);
+				}
+			}
+
+			return TRUE;
+			break;
+		} /* End of switch */
+	}
 	else {
 		switch (event->keyval) {
 		case GDK_Tab:
 		case GDK_KP_Tab:
 		case GDK_ISO_Left_Tab:
